# CBB

![Untitled](CBB%20fe89a720a04e445eb272517bcd9cd76e/Untitled.png)

1. 文件操作

---

问题：

- 文件、文件夹区分吗？
- 肯定会设计UI交互，传入函数形式？
- file-operation 是否能收束到一处？
- 相互调用问题？
- 国际化？
- 权限问题？
- 审批流程？
- 各模块需要加入应用store的机制-新
- 

---

思路：

- 纯js，函数形式
- UI交互，利用portal/callback，函数式，组织业务流程
- 目前个模块大体都是store形式，所以CBB纯函数形式，然后作为store action形式导入，避免迁移问题
- 相互调用问题，合并，分离，这个只能边做边看了，具体问题具体分析
- init 传参数，函数式国际化，去解决吧
- 尽量避免，相互调用，相互依赖
- 权限问题，肯定要独立模块去控制，cbb不提供权限能力
- 权限、审批、甚至之后的密级都分层处理，CBB只做具体业务逻辑
- 换句话说，前置条件不能影响CBB 代码
- filez-business 单包引入ts
- 由于store体系，只能遵循store写法，但是可以抽离单个函数，然后函数组合去做
- dispatch commit等store操作，需要想办法去解决

---

业务组件：

1. file-operation
    - 删除
    - 详情
    - 重命名
    - 收藏
    - 创建副本
    - 历史版本
    - 文件锁定
    - 预览
    - 编辑
    - 下载
    - 本地打开
    - 查找相关文档
    - 文件发布
    - 移动
    - 复制
    - 置顶
    - 添加到临时仓
    - 创建外链
    - 共享/授权
    - 评论

## CBB的基本概念

CBB即共通性建构基础（CommonBuildingBlock）指那些可以在不同产品、系统之间共用的零部件、模块、技术及其他相关的设计成果。CBB可以分为技术货架（平台）和产品货架（平台）。

技术货架和产品货架是相互融合的，一般来说技术货架可以产生不同的产品货架，产品货架也是融入了一个或者多个技术货架而形成的。

对于产品货架，又可以包括三个层次：CBB模块、CBB平台以及CBB货架。

CBB模块可以包括共享器件、共享组件、共享单板或模板、共享单机、共享整机、共享分系统、共享系统等；CBB平台即CBB模块组合，是由若干共享单机、共享整机或模块经组合形成共享平台，可供多个产品重用；而CBB货架是由CBB模块和CBB平台按层次进行分类而形成的。

由此可见，当产品是基于许多成熟的共享的CBB搭建而成的话，无疑产品的质量、进度和成本会得到更好的控制和保证。有机构调查认为，缺乏CBB的企业，研发人员将有60%左右的重复劳动用于研发已经存在的成果。

CBB的建设的好处

通过重用共享资源，在继承中创新，可以大大提高通用产品的成熟度和产品质量，总结起来有以下一些好处：

- 技术和软硬件被大量共享，极大降低研发和生产成本；
- 在共享基础上，增加新技术、新特性，能够快速开发新产品，对市场做出快速反应；
- 共享成熟度高的货架产品，大大增加了产品稳定性和可靠性；
- 通过共享，减少低水平重复，释放大量人力资源；
- 中间货架产品，比如模板、单机，可以独立开拓增量市场，进一步做大经营规模。

由此可见CBB建设的投资必将最终得到丰厚的回报。

对于前端同学来说， 业务组件库肯定不陌生，很多前端团队都会选择建设业务组件库来解决

1. 业务组件跨项目复用的问题
2. 同时统一代码实现，统一代码质量

从而提高业务的开发效率。但是我发现埋在明确需求之后，开始调研技术方案时，很多同学并不清楚要调研哪些技术点，怎么找到某个具体方向的解决方案，找到方案之后都需要试哪些case, 以及怎么把这些方案集成在一起等等。

其实不用想那么复杂，你只需要按照以下三个技术实现的关键点搞定就可以了。

- 第一步："搭地基"--业务组件库的整体架构设计
- 第二步："建主体结构"--业务组件库的基础技术设计
- 第三步:"粉刷外立面"-- 业务组件库的对外文档服务

你一定觉得这三个点还是太宏观了，不好理解，所以接下来，我就分别介绍这三个关键点到底是什么。你可以参考这些关键点来进行相关技术调研

## 一. 业务组件库的整体架构设计

对于业务组件库的整体架构设计而言，**核心问题是业务组件库的代码时如何来组织和管理**。

首先，我们把代码仓库建好。业界一般会把同一类组件库用单个仓库的形式维护，并且把组件开发成NPM包的形式，这里的重点是，**你要考虑把所有的组件打包成一个大的NPM包，还是分割是一个个独立的小NPM包 。 **不要小看这个问题， 这两种选择会使仓库的目录结构有不小的差异，进一步又会影响到后面组件的开发，构建，发布，实现的技术设计

### 单包架构

**是什么**

如果你选择把所有的组件看成一个整体，一起打包发布。这叫做**单包架构**。单个仓库，单个包，统一维护统一管理。比如Antd

[https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a052bb87f624971bbcabcfd0908e02e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a052bb87f624971bbcabcfd0908e02e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

**优点**

它最大的优点是可以通过相对路径实现组件与组件的引用，公共代码之间的引用。

**缺点**

缺点就是组件完全耦合在了一起，必须把它作为一个整体统一发包。就算只改一个组件的一个非常小的功能，都要对整个包发布更新。

---

比如说 Antd，它就是作为一个整体的包来尽进行管理的。选择使用单包架构的话，那么你就必须提供按需加载的能力，以降低使用者的成本，你可以考虑支持 ES Modules 的 Tree shaking 的功能来实现按需加载的能力。 当然你也可以选择另外一种方案，叫做"多包架构"

### 多包架构

**是什么**

每个组件彼此独立，单独打包发布，单个仓库多个包，统一维护单独管理。

```
 .
 ├── lerna.json
 ├── package.json
 └── packages/ # 这里将存放所有子 repo 目录
    ├── project_1/  # 组件1的包
    │   ├── index.js
    │   ├── node_modules/
    │   └── package.json
    ├── project_2/   # 组件2的包
    │   ├── index.js
    │   ├── node_module/
    │   └── package.json
    ...

复制代码
```

**优点**

它最大的优势是组件发布灵活，并且天然支持按需使用，

**缺点**

缺点就是组件与组件之间物理隔离。对于相互依赖，公共代码抽象等场景，就只能通过NPM包引用的方式来实现。

- -

在这些场景下的开发统一发布，相对来说没那么方便，多包架构在业界称之为 "Monorepo".

[https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8c90e5a0c674bc8ba203bee384324e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8c90e5a0c674bc8ba203bee384324e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

## 二. 业务组件库的基础技术能力

当你确定了整体架构之后，就可以开始具体的功能点实现了。业务组件库要求整体框架提供五点基础的技术能力

### 1. 构建能力

这需要我们可以提供构建产物的能力，这里有很多选择，可以选择Webpack，Rollup  Glup  Grunt.....  构建组件库推荐Rollup， 构建项目推荐Webpack. 这里需要特别注意产物的格式要求，像我们常用的cjs, esm,umd格式。

- 比如说如果你的组件考虑支持 node环境， 像需要支持ssr, 你就需要打包出 cjs格式的代码
- 如果你的组件考虑支持 `<script >` 标签引用，, 你就需要打包出 umd格式的代码

然后就需要在对应的构建工具里进行配置

除此之外，还有几个非常容易遗漏的点，比如说

- 组件库Bable的配置是否与项目中Babel的配置重复
- 依赖包是打包到产物中，还是使用项目中的依赖包。如:lodash, moment...
- 依赖包的样式是否打包到产物中以及Polyfill的配置(这里以后再开一篇详细说明吧😂)

### 2. 文档

你需要提供一个可以实时运行的文档服务。 包括支持静态内容的展示，以及可以查看源码的实施运行效果，这方面有很多优秀的开源库,比如 [StoryBook](https://link.juejin.cn/?target=https%3A%2F%2Fstorybook.js.org%2Fdocs%2Freact%2Fget-started%2Fintroduction)&[Styleguidist](https://link.juejin.cn/?target=https%3A%2F%2Freact-styleguidist.js.org%2F)，[Docz](https://link.juejin.cn/?target=https%3A%2F%2Fwww.docz.site%2F)

这里你需要注意一个典型的错误行为，那就是调研的时候，只调研一些基础的功能就开始做选择，这样很容易给后面挖坑，你需要考虑尽可能多的情况。 比如

1. 有内部状态的代码示例能不能支持，例如弹窗类的组件，就需要在示例中做显示状态的切换
2. 如果考虑放移动端组件，那么展示效果能不能支持，一般来说，移动端的示例，应该是通过iframe的形式运行在一个独立的页面里面。比如说，fiexd定位的移动端组件是很常见的一种形式，如果不是iframe，fiexd定位的元素会铺满整个文档网页

[https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a31b71f4c7c4aa4b19be70c54f26028~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a31b71f4c7c4aa4b19be70c54f26028~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

1. 文档网站的依赖包跟组件的依赖包会不会冲突。假设两个依赖包版本不一致的时候，需要实现一个样式的隔离

### 3. 本地服务

业界一般都是用文档服务来当本地服务的。启动本地的文档服务就可以查看运行的效果。这里你需要关注的是，本地服务的使用体验好不好，比如

- 说有没有热更新
- 编译速度够不够快

还有一个比较特别的点，有时候我们会在本地执行build构建。构建的产物跟本地生成的临时产物要能够做到相互隔离，互不影响

### 4. 质量保证

一方面我们需要提供统一的eslint功能。保证基础的实现风格和质量

另一方面可以考虑引入单元测试的能力，业界也有很对优秀的单测框架，如Jest ，Karma

### 5. 数据统计

需要统计组件被多少项目使用，具体在哪个地方使用。这个能力的主要目的是提供统计数据以及了解改动的参考影响范围。

你可以通过

- 组件内增加埋点 来进行统计。埋点方案会有一个时效性的限制，在你统计的时间周期内，如果说该组件的功能没有用户用到的这种情况是统计不到的
- 定时扫描分析所有代码仓库依赖来进行统计。可以搜索关键词 dependency tree

---

除了上诉几点能力以外，业务组件库还要求整体框架提供统一换肤的能力，快速创建新标准组件的能力，批量处理组件的能力，以及预置命名等等

像发包的命令，自测的命令，自动生成ChangeLog等等这样的命令。

## 三. 业务组件库的对外文档服务

当基础的能力都准备好之后，我们最后再关注一下对外的一个输出。也就是我们的文档网站。这里我们需要把它当成一个线上服务来搭建，这里需要考虑一个具体的架构是什么

1. 可能是纯静态资源
2. 配到的CI怎么搭建

## 总结

以上就是业务组件库技术实现的几个关键点，下面进行一个思维导图的总结

[https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bae602c396c74ad2ab9d3761a6004380~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bae602c396c74ad2ab9d3761a6004380~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

作者：望道同学链接：https://juejin.cn/post/6940978764293783588来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。